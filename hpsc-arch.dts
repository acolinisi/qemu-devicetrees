#include "hpsc-irqs.dtsh"
#include "hpsc-memmap.dtsh"
#include "hpsc-master-ids.dtsh"

/dts-v1/;

/ {
    #address-cells = <2>;
    #size-cells = <1>;

    /* We have to use a map, as opposed to the 'interrupt' property on each
       device if an interrupt might be connected to more than one interrupt
       controller. There's no way to specify that case with the 'interrupt'
       property alone, afaik.

       Also, we define the map in the root node, because the mappings must
       apply to device spread around different branches of the tree. An
       altenative might be to split the map definition into sections, one per the set
       of devices in each NIC/CCN, but that has the disadvantage that there won't be
       one list per interrupt controller where all inputs could be together, so that
       it is easy to number them consecutively and prevent mistakes.

       For now, the map is such that interrupt with ID N is mapped to the
       controller input number N. AFAIU, the interrupt controller input
       number has a correspondence to real HW, however the interrupt ID
       has meaning only inside this device tree definition.
    */
    interrupt-map = 
        /*                       TRCH                                          */
        /* 3-cell int specifier      int ctrl  ? input #              int type  */ 
#if 0 /* check how these are used before adding */
        <0 0 CRL_int_IRQ_0           &trch_nvic 0 CRL_int_IRQ_0           4>,
        <0 0 TRCH_IPI0_IRQ_0         &trch_nvic 0 TRCH_IPI0_IRQ_0         4>,
#endif
        <0 0 RTPS_TRCH_MAILBOX_IRQ_0 &trch_nvic 0 RTPS_TRCH_MAILBOX_IRQ_0 4>,
        <0 0 RTPS_TRCH_MAILBOX_IRQ_1 &trch_nvic 0 RTPS_TRCH_MAILBOX_IRQ_1 4>,
        <0 0 HPPS_TRCH_MAILBOX_IRQ_0 &trch_nvic 0 HPPS_TRCH_MAILBOX_IRQ_0 4>,
        <0 0 HPPS_TRCH_MAILBOX_IRQ_1 &trch_nvic 0 HPPS_TRCH_MAILBOX_IRQ_1 4>,
        <0 0 TRCH_DMA_IRQ_0          &trch_nvic 0 TRCH_DMA_IRQ_0          4>,
        <0 0 TRCH_DMA_IRQ_1          &trch_nvic 0 TRCH_DMA_IRQ_1          4>,

        /*                       RTPS                                          */
        /* 3-cell int specifier      int ctrl   ? input #              int type  */ 
#if 0 /* check how these are used before adding */
        <0 0 RPU_IPI0_IRQ_0          &rtps_gic 0 RPU_IPI0_IRQ_0          4>,
        <0 0 RPU_IPI1_IRQ_0          &rtps_gic 0 RPU_IPI1_IRQ_0          4>,
#endif
        <0 0 RTPS_TRCH_MAILBOX_IRQ_0 &rtps_gic 0 RTPS_TRCH_MAILBOX_IRQ_0 4>,
        <0 0 RTPS_TRCH_MAILBOX_IRQ_1 &rtps_gic 0 RTPS_TRCH_MAILBOX_IRQ_1 4>,
        <0 0 HPPS_RTPS_MAILBOX_IRQ_0 &rtps_gic 0 HPPS_RTPS_MAILBOX_IRQ_0 4>,
        <0 0 HPPS_RTPS_MAILBOX_IRQ_1 &rtps_gic 0 HPPS_RTPS_MAILBOX_IRQ_1 4>,
        <0 0 RTPS_DMA_IRQ_0          &rtps_gic 0 RTPS_DMA_IRQ_0          4>,
        <0 0 RTPS_DMA_IRQ_1          &rtps_gic 0 RTPS_DMA_IRQ_1          4>,

        /*                       HPPS                                          */
        /* 3-cell int specifier      int ctrl   ? input #              int type  */ 
#if 0 /* check how these are used before adding */
        <0 0 CRF_int_IRQ_0           &hpps_gic  0 CRF_int_IRQ_0           4>,
        <0 0 RPU_IPI1_IRQ_0          &hpps_gic  0 RPU_IPI1_IRQ_0          4>,
        <0 0 APU_IPI0_IRQ_0          &hpps_gic  0 APU_IPI0_IRQ_0          4>,
#endif
        <0 0 HPPS_TRCH_MAILBOX_IRQ_0 &hpps_gic  0 HPPS_TRCH_MAILBOX_IRQ_0 4>,
        <0 0 HPPS_TRCH_MAILBOX_IRQ_1 &hpps_gic  0 HPPS_TRCH_MAILBOX_IRQ_1 4>,
        <0 0 HPPS_RTPS_MAILBOX_IRQ_0 &hpps_gic  0 HPPS_RTPS_MAILBOX_IRQ_0 4>,
        <0 0 HPPS_RTPS_MAILBOX_IRQ_1 &hpps_gic  0 HPPS_RTPS_MAILBOX_IRQ_1 4>,
        <0 0 HSIO_UART0_IRQ_0        &hpps_gic  0 HSIO_UART0_IRQ_0        4>,
        <0 0 XGMAC_IRQ_0             &hpps_gic  0 XGMAC_IRQ_0             4>,
        <0 0 XGMAC_IRQ_1_WAKE        &hpps_gic  0 XGMAC_IRQ_1_WAKE        4>,
        <0 0 HPPS_DMA_IRQ_0          &hpps_gic  0 HPPS_DMA_IRQ_0          4>,
        <0 0 HPPS_DMA_IRQ_1          &hpps_gic  0 HPPS_DMA_IRQ_1          4>,
        <0 0 SRIO0_DMA_IRQ_0         &hpps_gic  0 SRIO0_DMA_IRQ_0         4>,
        <0 0 SRIO0_DMA_IRQ_1         &hpps_gic  0 SRIO0_DMA_IRQ_1         4>,
        <0 0 SRIO1_DMA_IRQ_0         &hpps_gic  0 SRIO1_DMA_IRQ_0         4>,
        <0 0 SRIO1_DMA_IRQ_1         &hpps_gic  0 SRIO1_DMA_IRQ_1         4>;

    cpus {
        #size-cells = <0>;

        trch_cpus {
            #address-cells = <1>;

            trch_memattr_cpu: trch_memattr_cpu@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_TRCH_CPU>;
            };

            trch_cpu: trch_cpu {
                #address-cells = <1>;

                compatible = "cortex-m4-arm-cpu";
                device_type = "cpu";
                reg = <0>;

                gdb-id = "TRCH Cortex-M4";

                #interrupt-cells = <3>; /* without this, Qemu complains */

                clock-frequency = <100000000>;
                d-cache-line-size = <0x20>;            
                d-cache-size = <0x1000>;            
                i-cache-line-size = <0x20>;        
                i-cache-size = <0x200>;

                arm,midr = <0x410fc240>;
                arm,ctr = <0x83338003>;
                arm,clidr = <0x09200003>;
                arm,id_pfr0 = <0x30>;
                arm,ccsidr1 = <0x24770011>;

                timebase-frequency = <100000000>;

                mr = <&trch>;
                memory = <&trch>;
                memattr_ns = <&trch_memattr_cpu>;
                /* TODO: memattr_s, mr-secure : ? */
            };
        };

        rtps_cpus {
            #address-cells = <1>;

#define RTPS_CPU_PROPS                                 \
                compatible = "cortex-r5f-arm-cpu";     \
                device_type = "cpu";                   \
                #interrupt-cells = <1>;                \
                d-cache-line-size = <0x20>;            \
                d-cache-size = <0x8000>;               \
                i-cache-line-size = <0x20>;            \
                i-cache-size = <0x8000>;               \
                arm,midr=<0x411fc153>;                 \
                arm,tcmtr=<0x00010001>;                \
                arm,ctr=<0x8003c003>;                  \
                arm,clidr=<0x09200003>;                \
                arm,ccsidr0 = <0xf01fe019>;            \
                arm,ccsidr1 = <0xf01fe019>;            \
                arm,id_pfr0 = <0x131>;                 \
                arm,reset-hivecs = <1>;                \

            rtps_memattr_cpu0: rtps_memattr_cpu@0 {
                    compatible = "qemu:memory-transaction-attr";
                    secure = <1>;
                    master-id = <MASTER_ID_RTPS_CPU0>;
            };
            rtps_cpu0: rtps_cpu@0 {
                RTPS_CPU_PROPS
                reg = <0>;
                gdb-id = "RTPS Cortex-R52 #0";
                arm,mp-affinity = <0x200>;

                mr = <&rtps0>;
                memory = <&rtps0>;

                /* TODO: memattr_s = ? */
                memattr_ns = <&rtps_memattr_cpu0>;

                // crl 0: controller_gpios: RST_R5(0)
                // rpu_ctrl 0: controller_gpios: R5_0_HALT
                // rpu_ctrl 7:                 : wfi_in_0
                // IS_MULTI_ARCH() = nothing
                gpios = <&crl 0 &rpu_ctrl 0 &rpu_ctrl 5 >;
                gpio-names = "reset", "ncpuhalt", "vinithi";
            };

            rtps_memattr_cpu1: rtps_memattr_cpu@1 {
                    compatible = "qemu:memory-transaction-attr";
                    secure = <1>;
                    master-id = <MASTER_ID_RTPS_CPU1>;
            };
            rtps_cpu1: rtps_cpu@1 {
                RTPS_CPU_PROPS
                reg = <1>;
                gdb-id = "RTPS Cortex-R52 #1";
                arm,mp-affinity = <0x201>;

                mr = <&rtps1>;
                memory = <&rtps1>;

                /* TODO: memattr_s = ? */
                memattr_ns = <&rtps_memattr_cpu1>;

                // crl 1: controller_gpios: RST_R5(1)
                // rpu_ctrl 1: controller_gpios: R5_1_HALT
                // rpu_ctrl 8:                 : wfi_in_1
                // IS_MULTI_ARCH() = nothing
                /* still, cannot find "halt" */
                gpios = <&crl 1 &rpu_ctrl 2 &rpu_ctrl 1 &rpu_ctrl 6 >;
                gpio-names = "reset", "halt", "ncpuhalt", "vinithi" ;
            };
        };

        hpps_cpus {
            #address-cells = <2>;

#define HPPS_CPU_PROS                                      \
                compatible = "cortex-a53-arm-cpu";        \
                device_type = "cpu";                      \
                #interrupt-cells = <1>;                   \
                d-cache-line-size = <0x20>;               \
                d-cache-size = <0x8000>;                  \
                i-cache-line-size = <0x20>;               \
                i-cache-size = <0x8000>;                  \
                arm,midr = <0x410fd032>;                  \
                arm,ctr = <0x83338003>;                   \
                arm,clidr = <0x09200003>;                 \
                arm,id_pfr0 = <0x1231>;                   \
                arm,ccsidr0 = <0x701fe019>;               \
                arm,ccsidr1 = <0x201fe019>;               \
                enable-method = "psci";                   \
                arm,reset-hivecs = <1>;                   \
                arm,rvbar = <0xfffff000>;                 \
                arm,reset-cbar = <A9_SCU>;                \
                mr = <&hpps>;                             \
                memory = <&hpps>;                         \


            hpps_memattr_cpu0_s: hpps_memattr_cpu_s@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_memattr_cpu0_ns: hpps_memattr_cpu_ns@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_cpu0: hpps_cpu@0 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #0";

                reg = <0x0 0>;
                arm,mp-affinity = <0>;

                gpios = <&crf 0>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu0_s>;
                memattr_ns = <&hpps_memattr_cpu0_ns>;
            };

            hpps_memattr_cpu1_s: hpps_memattr_cpu_s@1 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_memattr_cpu1_ns: hpps_memattr_cpu_ns@1 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU1>;
            };
            hpps_cpu1: hpps_cpu@1 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #1";

                reg = <0x0 1>;
                arm,mp-affinity = <1>;

                gpios = <&crf 1>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu1_s>;
                memattr_ns = <&hpps_memattr_cpu1_ns>;
            };

            hpps_memattr_cpu2_s: hpps_memattr_cpu_s@2 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU2>;
            };
            hpps_memattr_cpu2_ns: hpps_memattr_cpu_ns@2 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU2>;
            };
            hpps_cpu2: hpps_cpu@2 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #2";

                reg = <0x0 2>;
                arm,mp-affinity = <2>;

                gpios = <&crf 2>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu2_s>;
                memattr_ns = <&hpps_memattr_cpu2_ns>;
            };

            hpps_memattr_cpu3_s: hpps_memattr_cpu_s@3 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU3>;
            };
            hpps_memattr_cpu3_ns: hpps_memattr_cpu_ns@3 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU3>;
            };
            hpps_cpu3: hpps_cpu@3 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #3";

                reg = <0x0 3>;
                arm,mp-affinity = <3>;

                gpios = <&crf 3>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu3_s>;
                memattr_ns = <&hpps_memattr_cpu3_ns>;
            };

            hpps_memattr_cpu4_s: hpps_memattr_cpu_s@4 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU4>;
            };
            hpps_memattr_cpu4_ns: hpps_memattr_cpu_ns@4 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU4>;
            };
            hpps_cpu4: hpps_cpu@4 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #4";

                reg = <0x0 0x104>;
                arm,mp-affinity = <0x104>;

                gpios = <&crf 0x4>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu4_s>;
                memattr_ns = <&hpps_memattr_cpu4_ns>;
            };

            hpps_memattr_cpu5_s: hpps_memattr_cpu_s@5 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU5>;
            };
            hpps_memattr_cpu5_ns: hpps_memattr_cpu_ns@5 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU5>;
            };
            hpps_cpu5: hpps_cpu@5 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #5";

                reg = <0x0 0x105>;
                arm,mp-affinity = <0x105>;

                gpios = <&crf 0x5>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu5_s>;
                memattr_ns = <&hpps_memattr_cpu5_ns>;
            };
            hpps_memattr_cpu6_s: hpps_memattr_cpu_s@6 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU6>;
            };
            hpps_memattr_cpu6_ns: hpps_memattr_cpu_ns@6 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU6>;
            };
            hpps_cpu6: hpps_cpu@6 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #6";

                reg = <0x0 0x106>;
                arm,mp-affinity = <0x106>;

                gpios = <&crf 0x6>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu6_s>;
                memattr_ns = <&hpps_memattr_cpu6_ns>;
            };
            hpps_memattr_cpu7_s: hpps_memattr_cpu_s@7 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU7>;
            };
            hpps_memattr_cpu7_ns: hpps_memattr_cpu_ns@7 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU7>;
            };
            hpps_cpu7: hpps_cpu@7 {
                HPPS_CPU_PROS
                gdb-id = "HPPS Cortex-A53 #7";

                reg = <0x0 0x107>;
                arm,mp-affinity = <0x107>;

                gpios = <&crf 0x7>;
                gpio-names = "rst_cntrl";

                memattr_s = <&hpps_memattr_cpu7_s>;
                memattr_ns = <&hpps_memattr_cpu7_ns>;
            };

            /* TODO: is this used for anything? */
            cpu-map {
                cluster0 {
                    core0 { cpu = <&hpps_cpu0>; };
                    core1 { cpu = <&hpps_cpu1>; };
                    core2 { cpu = <&hpps_cpu2>; };
                    core3 { cpu = <&hpps_cpu3>; };
                };
                cluster1 {
                    core0 { cpu = <&hpps_cpu4>; };
                    core1 { cpu = <&hpps_cpu5>; };
                    core2 { cpu = <&hpps_cpu6>; };
                    core3 { cpu = <&hpps_cpu7>; };
                };
            };
        };
    };
    trch: trch { /* view of address space from TRCH CPU */
        compatible = "simple-bus";
        ranges ;

        trch_nvic: interrupt-controller@0xe000e000  {
            compatible = "arm,armv7m_nvic";
            interrupt-controller;
            #interrupt-cells = <3>;
            reg = <0x0 0xe000e000 0x1000>;
            num-irq = <256>;
            cpu-id = <0>; /* TODO: could this be a ref to the cpu node? */
        };

        trch_sram: trch_sram { /* TODO: or is SRAM a slave on nic1? */
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x0 TRCH_SRAM TRCH_SRAM_SIZE>;
        };

        to_nic1 {
            #priority-cells = <1>;
            compatible = "qemu:memory-region";
            alias = <&nic1>;
            reg = <0x0 0x0 /* size = */ 0xffffffff /* prio = -4 */ 0xfffffffc>;
        };
    };

    rtps: rtps { /* visible from both RTPS CPUs */
        compatible = "simple-bus";
        ranges ;

        rtps_gic: interrupt-controller@RTPS_GIC_DIST {
                #address-cells = <0>;
                #size-cells = <0>;
                #interrupt-cells = <3>;
                #gpio-cells = <0>;
                compatible = "arm,arm-gicv3";
                reg = < BASE_ADDR(RTPS_GIC_DIST)  0x20000  0    /* GICD */
                        BASE_ADDR(RTPS_GIC)      0x100000 0>;    /* GICR */
                interrupt-controller ;
                num-irq = <320>;
                /* interrupts-extended = TODO; */
                num-cpu = <2>;
                cpus = <1>; /* TODO: other cpus */
                revision = <3>;
                #redistributor-regions = <1>;
        };
/*
        rtps_gic: interrupt-controller@RTPS_GIC_DIST {
            #interrupt-cells = <3>;
            #size-cells = <0>;
            compatible = "xlnx,zynqmp-scugic", "arm,gic";
            reg = <    BASE_ADDR(RTPS_GIC_DIST) 0x0 0x1000 0x0
                BASE_ADDR(RTPS_GIC)      0x0  0x100 0x0>;
            status = "disabled";
            interrupt-controller ;
            num-irq = <256>;
            nUm-cpu = <2>;
            interrupts-extended =
                <&rtps_cpu0 0>,
                <&rtps_cpu1 0>;
        };
*/

        /* enabled in SPLIT mode only */
        ddr_memory_2_for_rpu: ddr_memory_2_for_rpu {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x30000) 0x00000000 0x00010000 0x0>;
        };

        to_nic2 {
            compatible = "qemu:memory-region";
            alias = <&nic2>;
            reg = <0x0 0x0 0xffffffff 0xffffffff /* prio */ 0xfffffffe /* -2 */>;
        };
    };

    rtps0: rtps@0 { /* view of address space from RTPS CPU0 */
        #size-cells = <2>;
        #priority-cells = <1>;

        compatible = "simple-bus";
        ranges ;

        tcm_cache_rpu0: tcm_cache_rpu0@0 {
            compatible = "qemu:memory-region";

            tcm_ram_r5_0_A: tcm_ram_r5_0_A@0x00000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x0) 0x0 0x10000 0x1>;
            };

            /* alias into RPU1 TCM for lockstep mode */
            atcm1_for_rpu0: atcm1_for_rpu0 {
                compatible = "qemu:memory-region";
                alias = <&tcm_ram_r5_1_A>;
                reg = <BASE_ADDR(0x10000) 0x0 0x10000 0x1>;
            };

            tcm_ram_r5_0_B: tcm_ram_r5_0_B@0x20000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x20000) 0x0 0x10000 0x1>;
            };

            /* alias into RPU1 TCM for lockstep mode */
            btcm1_for_rpu0: btcm1_for_rpu0 {
                compatible = "qemu:memory-region";
                alias = <&tcm_ram_r5_1_B>;
                reg = <BASE_ADDR(0x30000) 0x0 0x10000 0x1>;
            };

            icache_rpu0: icache_rpu0@0x40000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x40000) 0x8000>;
            };

            dcache_rpu0: dcache_rpu0@0x50000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x50000) 0x8000>;
            };
        };

        to_rtps {
            compatible = "qemu:memory-region";
            alias = <&rtps>;
            reg = <0x0 0x0 0xffffffff 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    rtps1: rtps@1 {  /* view of address space from RTPS CPU0 */
        #size-cells = <2>;
        #priority-cells = <1>;

        compatible = "simple-bus";
        ranges ;

        tcm_cache_rpu1: tcm_cache_rpu1@0 {
            compatible = "qemu:memory-region";

            tcm_ram_r5_1_A: tcm_ram_r5_1_A@0x00000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x0) 0x0 0x10000 0x1>;
            };

            tcm_ram_r5_1_B: tcm_ram_r5_1_B@0x20000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x20000) 0x0 0x10000 0x1>;
            };

            icache_rpu1: icache_rpu1@0x30000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x30000) 0x8000>;
            };

            dcache_rpu1: dcache_rpu1@0x40000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <BASE_ADDR(0x40000) 0x8000>;
            };
        };

        to_rtps {
            compatible = "qemu:memory-region";
            alias = <&rtps>;
            reg = <0x0 0x0 0xffffffff 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    hpps: hpps { /* view of address space from HPPS CPUs */
        compatible = "simple-bus";
        ranges ;

        hpps_gic: interrupt-controller@HPPS_GIC_DIST {
                #address-cells = <0>;
                #size-cells = <0>;
                #interrupt-cells = <3>;
                #gpio-cells = <0>;
                compatible = "arm,arm-gicv3";
                reg = < BASE_ADDR(HPPS_GIC_DIST)  0x20000 0    /* GICD */
                        BASE_ADDR(HPPS_GIC)      0x100000 0>;  /* GICR */
                interrupt-controller ;
                num-irq = <320>;
                interrupts-extended =
                        <&hpps_cpu0 0>, <&hpps_cpu1 0>, <&hpps_cpu2 0>, <&hpps_cpu3 0>,
                        <&hpps_cpu4 0>, <&hpps_cpu5 0>, <&hpps_cpu6 0>, <&hpps_cpu7 0>, 

                        <&hpps_cpu0 2>, <&hpps_cpu1 2>, <&hpps_cpu2 2>, <&hpps_cpu3 2>, 
                        <&hpps_cpu4 2>, <&hpps_cpu5 2>, <&hpps_cpu6 2>, <&hpps_cpu7 2>, 

                        <&hpps_cpu0 1>, <&hpps_cpu1 1>, <&hpps_cpu2 1>, <&hpps_cpu3 1>,
                        <&hpps_cpu4 1>, <&hpps_cpu5 1>, <&hpps_cpu6 1>, <&hpps_cpu7 1>, 

                        <&hpps_cpu0 3>, <&hpps_cpu1 3>, <&hpps_cpu2 3>, <&hpps_cpu3 3>, 
                        <&hpps_cpu4 3>, <&hpps_cpu5 3>, <&hpps_cpu6 3>, <&hpps_cpu7 3>,

                        <&hpps_gic 0x1 0x9 0x104>,
                        <&hpps_gic 0x1 0x9 0x204>,
                        <&hpps_gic 0x1 0x9 0x404>,
                        <&hpps_gic 0x1 0x9 0x804>;

                num-cpu = <8>;
                cpus = <3>; /* TODO: other cpus */
                revision = <3>;
                #redistributor-regions = <1>;
        };

        /* timer interrupt
            Secure Physical Timer event (ID 29 <= 16 + 13)
            Non-secure Physical Timer event (ID 30 <= 16 + 14)
            Virtual Timer event (ID 27 <= 16 + 11)
            Hypervisor Timer event (ID 26 <= 16 + 10) */
        timer {
            compatible = "arm,armv8-timer";
            interrupt-parent = <&hpps_gic>;
            interrupts = <1 13 0xff01>,
                         <1 14 0xff01>,
                         <1 11 0xff01>,
                         <1 10 0xff01>;
            clock-frequency = <100000000>;
        };
    };

    nic1: nic1 {
        #priority-cells = <1>;

        compatible = "simple-bus";
        ranges ;

        /* TODO: does this exist in HPSC? Which NIC is it connected to? */
        crl: crl@CRL_APB {
            gpio-controller;
            #gpio-cells = <1>;
            compatible = "xlnx,zynqmp-crl";
            reg = <BASE_ADDR(CRL_APB) 0x1000>;
            num-gpios = <16>; // is it controller(3) or client(1)?
            // pmu_global_client_gpios[] in xilinx_zynqmp_pmu_global.c
            //        : out: "error_2_out"
            // crl: controller_gpios : 0[RST_R5(0)], 1(RST_R5(1)], 2(SRST_B)
            // Then: if "error_2_out", RST_R5(0)?
#if 0 /* what is this used for? */
            gpios = <&pmu_global 26>;
#endif
        };

        trch_dma: dma-controller@TRCH_DMA {
            compatible = "arm,pl330", "arm,primecell";
            reg = <BASE_ADDR(TRCH_DMA) 0x1000>;
            interrupts = <TRCH_DMA_IRQ_0
                          TRCH_DMA_IRQ_1>;
            #dma-cells = <1>;
            dma = <&nic1>;
        };

        to_nic2 {
            compatible = "qemu:memory-region";
            alias = <&nic2>;
            reg = <0x0 0x38000000 0x1000 0x0>;
        };

        to_nic5 {
            compatible = "qemu:memory-region";
            alias = <&nic5>;
            reg = <0x0 0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    nic2: nic2 {
        #priority-cells = <1>;
        compatible = "simple-bus";
        ranges ;

        nic2_descend1 {
            compatible = "simple-bus";
            ranges ;
            nic2_descend2 {
                compatible = "simple-bus";
                ranges ;
                /* TODO: does this exist in HPSC? Which NIC is it connected to? */
                rpu_ctrl: rpu_control@RPU {
                    gpio-controller;
                    #gpio-cells = <1>;
                    compatible = "xlnx,rpu-control";
                    reg = <BASE_ADDR(RPU) 0x400 /* prio = */ 0>;
                    atcm1-for-rpu0 = <&atcm1_for_rpu0>;
                    btcm1-for-rpu0 = <&btcm1_for_rpu0>;
                    icache-for-rpu1 = <&icache_rpu1>;
                    dcache-for-rpu1 = <&dcache_rpu1>;
                    ddr-mem-for-rpu = <&ddr_memory_2_for_rpu>;
                    gic-for-rpu = <&rtps_gic>;
                };
            };
        };

        /* TODO: RTPS SPI */

        to_nic3 {
            compatible = "qemu:memory-region";
            alias = <&nic3>;
            reg = <0x0 0x0 0xffffffff /* prio = -1 */ 0xffffffff>;
        };
            
    };

    rtps_smmu_tbu0: rtps_smmu_tbu0 {
        compatible = "simple-bus";
        ranges ;
    };

    nic3: nic3 {
        compatible = "simple-bus";
        ranges ;

        rtps_ddr_low: rtps_ddr_low { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            reg = <BASE_ADDR(RTPS_DDR_LOW) 0x40000000>;
        };

        rtps_smmu_reg: smmu_reg0@RTPS_SMMU_REG {
            compatible = "xlnx,smmu-reg";
            reg = <BASE_ADDR(RTPS_SMMU_REG) 0x1000>;
            interrupt-controller;
            interrupts = <RTPS_SMMU_IRQ>;
        };

        rtps_smmu: smmu0@RTPS_SMMU {
            compatible = "arm,mmu-500";
            reg-extended = <&nic3 BASE_ADDR(RTPS_SMMU) 0x10000 /* nic3? */
                            &rtps_smmu_tbu0 BASE_ADDR(0) 0xffffffff 0xffffffff
                            /* &rtps_smmu_tb1 "PCIE" */
                            >;

            interrupt-parent = <&rtps_smmu_reg>;
            interrupts = <0 1 2 3 4 5 6 7 8
                          8 9 10 11 12 13 14 15 16
                          17>;

            /* dma:  points to the MR used for PTWs.  */
            /* mr-x: points to the per TBU down-stream MR.  */
            dma = <&nic3>;
            mr-0 = <&nic3>;
            /* mr-1 = <&pcie>; */
        };

        rtps_dma: dma-controller@RTPS_DMA {
            compatible = "arm,pl330", "arm,primecell";
            reg = <BASE_ADDR(RTPS_DMA) 0x1000>;
            interrupts = <RTPS_DMA_IRQ_0
                          RTPS_DMA_IRQ_1>;
            #dma-cells = <1>;
            dma = <&rtps_smmu_tbu0>;
        };

    };

    nic4: nic4 { /* lsio */
        compatible = "simple-bus";
        ranges ;

        rtps_trch_mailbox: mailbox@RTPS_TRCH_MAILBOX {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <RTPS_TRCH_MAILBOX_IRQ_0 RTPS_TRCH_MAILBOX_IRQ_1>;
            reg = <BASE_ADDR(RTPS_TRCH_MAILBOX) 0x80000>;
        };

        lsio_uart_0: serial@LSIO_UART0 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <BASE_ADDR(LSIO_UART0) 0x1000>;
            current-speed = <115200>;
            interrupts = <LSIO_UART0_IRQ_0>;
            port-number = <0>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
            status = "disabled";
        };

#if 0
        lsio_uart_0: serial@LSIO_UART1 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <BASE_ADDR(LSIO_UART1) 0x1000>;
            current-speed = <115200>;
            interrupts = <LSIO_UART1_IRQ_0>;
            port-number = <0>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
            status = "disabled";
        };
#endif

            /* TODO: SMC353 */
            /* TODO: GPIO */
            /* TODO: I2C */
            /* TODO: SPI */
    };

    nic5: nic5 {
        #priority-cells = <1>;
        compatible = "simple-bus";
        ranges ;

        hpps_smmu0_reg: smmu_reg0@HPPS_SMMU0_REG {
            compatible = "xlnx,smmu-reg";
            reg = <BASE_ADDR(HPPS_SMMU0_REG) 0x1000 /* prio = */ 0x0>;
            interrupt-controller;
            interrupts = <HPPS_SMMU0_IRQ>;
        };

        hpps_smmu0: smmu0@HPPS_SMMU0 {
            compatible = "arm,mmu-500";
            reg-extended = <&nic5 BASE_ADDR(HPPS_SMMU0) 0x10000  /* prio = */ 0x0 /* nic5? */
                            &nic5 BASE_ADDR(0) 0xffffffff 0xffffffff  /* prio = */ 0x0>; /* master connected to slave interface of MMU */

            interrupt-parent = <&hpps_smmu0_reg>;
            interrupts = <0 1 2 3 4 5 6 7 8
                            8 9 10 11 12 13 14 15 16
                            17>;

            /* dma:  points to the MR used for PTWs.  */
            /* mr-x: points to the per TBU down-stream MR.  */
            dma = <&ccn>;
            mr-0 = <&ccn>;
            /* mr-1 = <&pcie>; */

        };

        to_nic4 { /* lsio */
                compatible = "qemu:memory-region";
                alias = <&nic4>;
                reg = <0x0 0x02800000 0x2e000000 /* prio = */ 0x0>;
        };

    };

    nic6: nic6 {
        compatible = "simple-bus";
        ranges ;

        hpps_trch_mailbox: mailbox@HPPS_TRCH_MAILBOX {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <HPPS_TRCH_MAILBOX_IRQ_0 HPPS_TRCH_MAILBOX_IRQ_1>;
            reg = <BASE_ADDR(HPPS_TRCH_MAILBOX) 0x80000>;
        };

        hpps_rtps_mailbox: mailbox@HPPS_RTPS_MAILBOX {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <HPPS_RTPS_MAILBOX_IRQ_0 HPPS_RTPS_MAILBOX_IRQ_1>;
            reg = <BASE_ADDR(HPPS_RTPS_MAILBOX) 0x80000>;
        };

        hsio_uart_0: serial@UART0 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <BASE_ADDR(HSIO_UART0) 0x1000>;
            current-speed = <115200>;
            interrupts = <HSIO_UART0_IRQ_0>;
            port-number = <1>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
        };
            /* TODO: SMC353 */
    };

    hpps_smmu1_tbu_dma: hpps_smmu1_tbu_dma {
        compatible = "simple-bus";
        ranges ;
    };

    hpps_smmu1_tbu_xgmac: hpps_smmu1_tbu_xgmac {
        compatible = "simple-bus";
        ranges ;
    };

    nic7: nic7 {
        compatible = "simple-bus";
        ranges ;

        hpps_smmu1_reg: smmu_reg0@HPPS_SMMU1_REG {
                compatible = "xlnx,smmu-reg";
                reg = <BASE_ADDR(HPPS_SMMU1_REG) 0x1000>;
                interrupt-controller;
                interrupts = <HPPS_SMMU1_IRQ>;
        };

        hpps_smmu1: smmu1@HPPS_SMMU1 {
                compatible = "arm,mmu-500";
                reg-extended = <&nic7 BASE_ADDR(HPPS_SMMU1) 0x10000 /* nic7? */
                                &hpps_smmu1_tbu_dma   BASE_ADDR(0) 0xffffffff 0xffffffff
                                &hpps_smmu1_tbu_xgmac BASE_ADDR(0) 0xffffffff 0xffffffff>;

                interrupt-parent = <&hpps_smmu1_reg>;
                interrupts = <0 1 2 3 4 5 6 7 8
                                8 9 10 11 12 13 14 15 16
                                17>;

                /* dma:  points to the MR used for PTWs.  */
                /* mr-x: points to the per TBU down-stream MR.  */
                dma = <&nic7>;
                mr-0 = <&nic7>;
                /* mr-1 = <&pcie>; */
        };
            
        hpps_dma: dma-controller@HPPS_DMA {
            compatible = "arm,pl330", "arm,primecell";
            reg = <BASE_ADDR(HPPS_DMA) 0x1000>;
            interrupts = <HPPS_DMA_IRQ_0
                          HPPS_DMA_IRQ_1>;
            #dma-cells = <1>;
            dma = <&hpps_smmu1_tbu_dma>;
        };

        srio0_dma: dma-controller@SRIO0_DMA {
            compatible = "arm,pl330", "arm,primecell";
            reg = <BASE_ADDR(SRIO0_DMA) 0x1000>;
            interrupts = <SRIO0_DMA_IRQ_0
                          SRIO0_DMA_IRQ_1>;
            #dma-cells = <1>;
                        dma = <&nic7>;
        };

        srio1_dma: dma-controller@SRIO1_DMA {
            compatible = "arm,pl330", "arm,primecell";
            reg = <BASE_ADDR(SRIO1_DMA) 0x1000>;
            interrupts = <SRIO1_DMA_IRQ_0
                          SRIO1_DMA_IRQ_1>;
            #dma-cells = <1>;
            dma = <&nic7>;
        };

        xgmac: ethernet@XGMAC {
            #stream-id-cells = <0x1>;
            #address-cells = <1>;
            #size-cells = <0>;
            reg = <BASE_ADDR(XGMAC) 0x1000>;
            clock-names = "hclk", "pclk";
            clocks = <&misc_clk>, <&misc_clk>;
            compatible = "xlnx,ps7-ethernet-1.00.a", "cdns,gem";  /* TODO: change to Synopsys DWC_ether */
            interrupts = <XGMAC_IRQ_0 XGMAC_IRQ_1_WAKE>;
            dma = <&hpps_smmu1_tbu_xgmac>;
            memattr = <&xgmac_memattr>;
            local-mac-address = [00 0a 35 00 02 90];
            num-priority-queues = <2>;
            revision = <0x40070106>;

            xgmac_memattr: xgmac_memattr@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_XGMAC>;
            };
        };

        /* TODO: PCIe */
        /* TODO: Spacewire */
        /* TODO: TTE */
    };

    ccn: ccn {
        #priority-cells = <1>;
        compatible = "simple-bus";
        ranges ;

        hpps_ddr_low: hpps_ddr_low { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            reg = <BASE_ADDR(HPPS_DDR_LOW) 0x40000000 /* prio = */ 0x0>;
        };

        /* TODO: does this exist in HPSC? Which NIC is it connected to? */
        crf: crf@CRF_APB {
            compatible = "xlnx,zynqmp_crf";
            reg = <BASE_ADDR(CRF_APB) 0x110 /* prio = */ 0x0>;
            gpio-controller;
            #gpio-cells = <1>;
        };

        to_nic6 {
            compatible = "qemu:memory-region";
            alias = <&nic6>;
            reg = <BASE_ADDR(0xF9220000) 0x000C0000 /* prio = -1 */ 0xffffffff>;
        };

        to_nic7 {
            compatible = "qemu:memory-region";
            alias = <&nic7>;
            reg = <BASE_ADDR(0xE3000000) 0x02330000 /* prio = -1 */ 0xffffffff>;
        };
    };

    uart_clk: uart_clk {
        #clock-cells = <0>;
        clock-frequency = <25000000>;
        compatible = "fixed-clock";
    };

    misc_clk: misc_clk {
        #clock-cells = <0>;
        clock-frequency = <50000000>;
        compatible = "fixed-clock";
    };

    /* arm_generic_fdt insists on having a memory node at root: we won't use this */
    dummy_memory: memory {
        compatible = "qemu:memory-region";
        qemu,ram = <1>;
        reg = <0x0 0x0 0xffffffff>;
    };
};
